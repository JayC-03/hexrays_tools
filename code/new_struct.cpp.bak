#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <hexrays.hpp>
#include <struct.hpp>
#include <bytes.hpp>
#include <kernwin.hpp>
#include <algorithm>
#include <pro.h>
#include <srarea.hpp>
#include <auto.hpp>
#include <funcs.hpp>

#include <expr.hpp>//for VT_LONG
#include <frame.hpp>//for recalc_spd

#include "choosers.h"
#include "structures.h"
#include "negative_cast.h"
#include "helpers.h"
#include "struct_graph.h"
#include "classes_view.h"
#include "classes.h"

#include "new_struct.h"

#define ida_local

//typedef strtype_info_t

#include "ripped.h"


extern tid_t create_VT_struc(ea_t VT_ea, char * name,size_t namelen, uval_t idx );

tid_t is_vt(ea_t ea)
{
	//1. at ea is struct which we already created

	//2. ea looks like vftable
	return create_VT_struc(ea, NULL, 0, -1);
}


struct ida_local ptr_checker_t : public ctree_parentee_t
{
	bool need_field_info;
	field_info_t & fields;
	//int idx; // index of the var in question
	std::set<int> idxs;

	bool is_our(int idx)
	{
		return idxs.find(idx)!=idxs.end();	
	}

	int idaapi visit_expr(cexpr_t *e)
	{
		scan_info_t si;

		if ( e->op == cot_asg )	
		{
			if ( e->x->op == cot_var  && !is_our(e->x->v.idx))
			{
				if ( e->y->op == cot_var  && is_our(e->y->v.idx))
				{
					//necessary for now
					if(e->y->type == e->x->type)
					{
						idxs.insert(e->x->v.idx);											
					}
					msg("scanning also var %d\n", e->x->v.idx);
				}
			}
		}

		if ( e->op == cot_var && is_our(e->v.idx)  )
		{ // found our var. are we inside a pointer expression?
			uint64 delta = 0;
			bool delta_defined = true;
			int i = parents.size() - 1;
			if ( parents[i]->op == cot_add ) // possible delta
			{
				cexpr_t *d = ((cexpr_t*)parents[i])->theother(e);
				delta_defined = d->get_const_value(&delta);
				i--;
			}
			/*
			// more additions or subtractions are allowed but spoil the delta
			while ( parents[i]->op == cot_add || parents[i]->op == cot_sub )
			{
			i--;
			delta_defined = false;
			}
			*/

			typestring t;

#if 1//vftable handling
			{
			int j = i;
			while ( parents[j]->op == cot_cast ){j--;}

			if (parents[j]->op == cot_ptr && parents[j-1]->op == cot_asg )
			{
				cexpr_t * asg = ((cexpr_t*)parents[j-1]);
				if (asg->y->op == cot_ref)
				{
					if (asg->y->x->op == cot_obj)
					{
						cexpr_t * obj = (cexpr_t*)asg->y->x;
						if ( isEnabled(obj->obj_ea) )
						{
							tid_t tid = is_vt(obj->obj_ea);
							if(tid!=BADNODE)
							{
								char name[MAXNAMELEN];
								get_struc_name(tid, name, sizeof(name));
								t = make_pointer(make_pointer(create_typedef(name)));
								si.is_VT = true;
								si.type = t;
								si.is_protected = false;
							}						
						}
					}
				}			
			}
			}


#endif
			/*

			*/
			if ( delta_defined )
			{
				// skip casts
				typestring type;
				if(t.empty())
				{
					while ( parents[i]->op == cot_cast )
					{
						type = ((cexpr_t*)parents[i])->type;
						i--;
					}
				}
				else
				{
					type = t;
				}
				if ( type.is_ptr() )
				{
					if ( !need_field_info )
						return 1; // yes, can be converted to ptr
					type = remove_pointer(type);
					if ( type.is_void() ) // all we have is void*
						type = t_char;


					scan_info_t &sif  = fields[uval_t(delta)];
					//sif.type = type;
					if (si.is_VT)
					{
						sif.is_VT =  true;
						sif.type = si.type;
					}					

					if (sif.is_VT && !si.is_VT)
					{
						return 0;
						//this is virtual call probably
						//do nothing
					}
					sif.type = type;

				}
			}
		}
		return 0;
	}
	ptr_checker_t(int i, bool nfi, field_info_t * fi) : need_field_info(nfi), fields(*fi) {idxs.insert(i);}
};


bool can_be_converted_to_ptr(cfunc_t *cfunc, int varidx, strtype_info_t *strinfo)
{
	lvars_t * lvars = cfunc->get_lvars();
	if(!lvars)
		return false;
	lvar_t & lv = (*lvars)[varidx] ;

	if ( lv.type().is_ptr() )
		return false; // already ptr
	if ( lv.width != inf.cc.size_i )
		return false; // not quite correct but ok for now

	field_info_t fields;
	ptr_checker_t pc(varidx, strinfo != NULL, &fields);
	if ( !pc.apply_to((citem_t*)&cfunc->body, NULL) && fields.empty() )
		return false;

	if ( strinfo != NULL )
	{
		int minalign = inf.cc.defalign;
		uval_t off = 0;
		strtype_info_t &si = *strinfo;
		for ( field_info_t::iterator p=fields.begin(); p != fields.end(); ++p )
		{
			if ( p->first < off )
				continue; // skip overlapping fields
			meminfo_t &mi = si.push_back();
			mi.offset = p->first;
			while ( (mi.offset & (minalign-1)) != 0 )
				minalign >>= 1;
			mi.type = p->second.type;
			mi.name = create_field_name.call(&mi.type, mi.offset); //170C8AA0 - int create_field_name(qstring *a1, typestring *a2, int offset)
			mi.size = p->second.type.size();
			//todo

			mi.fields = dummy_plist_for.call(mi.type.u_str());
			off = mi.offset + mi.size;
		}
		si.basetype = BTF_STRUCT;
		si.N = (si.size() << 3);
		if ( minalign < inf.cc.defalign )
			si.N |= log2ceil(minalign)+1;
	}
	return true;
}

//-------------------------------------------------------------------------
// this functions assumes that the structure fields come one after another without gaps
static void build_struct_type(
							  const strtype_info_t &strinfo,
							  typestring &outtype,
							  typestring &outfields)
{
	QASSERT(50641, (strinfo.N >> 3) == strinfo.size());
	outtype.clear();
	outfields.clear();
	outtype.before(strinfo.basetype);
	outtype += make_dt.call(strinfo.N);

	int offset = 0;
	for ( int i=0; i < strinfo.size(); i++ )
	{
		type_t buf[MAXSTR];
		const meminfo_t &mi = strinfo[i];
		make_dtname.call(buf, sizeof(buf), mi.name.c_str());
		outtype   += mi.type;
		outfields += buf;
		outfields += mi.fields;
		QASSERT(50642, mi.offset == offset);
		offset = mi.offset + mi.size;
	}
}

//-------------------------------------------------------------------------
static int add_gaps(strtype_info_t &strinfo)
{
	int cnt = 0;
	int offset = 0;
	for ( int i=0; i < strinfo.size(); i++ )
	{
		const meminfo_t &mi = strinfo[i];
		if ( mi.offset != offset )
		{
			sval_t gapsize = mi.offset - offset;
			QASSERT(50643, gapsize > 0);
			meminfo_t gap;
			gap.size = gapsize;
			gap.offset = offset;
			gap.type = make_array(t_byte, gapsize);
			gap.name.sprnt("f%X", offset);
			strinfo.insert(strinfo.begin()+i, gap);
			cnt++;
			offset += gapsize;
		}
		else
		{
			offset = mi.offset + mi.size;
		}
	}
	strinfo.N = (strinfo.N & 7) | (strinfo.size() << 3);
	return cnt;
}


//-------------------------------------------------------------------------
bool __fastcall strtype_info_t::build_udt_type(typestring &restype, typestring &resfields)
{
	if ( empty() )
		return false;
	add_gaps(*this);
	build_struct_type(*this, restype, resfields);
	return true;
}


bool can_be_converted_to_ptr2(cfunc_t *cfunc, int varidx, strtype_info_t *strinfo, field_info_t * fields)
{
	lvars_t * lvars = cfunc->get_lvars();
	if(!lvars)
		return false;
	lvar_t & lv = (*lvars)[varidx] ;

	if ( lv.type().is_ptr() )
		return false; // already ptr
	if ( lv.width != inf.cc.size_i )
		return false; // not quite correct but ok for now


	ptr_checker_t pc(varidx, strinfo != NULL, fields);
	if ( !pc.apply_to((citem_t*)&cfunc->body, NULL) && pc.fields.empty() )
		return false;
}

bool can_be_converted_to_ptr3(cfunc_t *cfunc, int varidx, strtype_info_t *strinfo, field_info_t * fields)
{
	if ( strinfo != NULL )
	{
		int minalign = inf.cc.defalign;
		uval_t off = 0;
		strtype_info_t &si = *strinfo;
		for ( field_info_t::iterator p=fields->begin(); p != fields->end(); ++p )
		{
			if ( p->first < off )
				continue; // skip overlapping fields
			meminfo_t &mi = si.push_back();
			mi.offset = p->first;
			while ( (mi.offset & (minalign-1)) != 0 )
				minalign >>= 1;
			mi.type = p->second.type;
			mi.name = create_field_name.call(&mi.type, mi.offset); //170C8AA0 - int create_field_name(qstring *a1, typestring *a2, int offset)
			mi.size = p->second.type.size();
			//todo

			mi.fields = dummy_plist_for.call(mi.type.u_str());


			off = mi.offset + mi.size;
		}
		si.basetype = BTF_STRUCT;
		si.N = (si.size() << 3);
		if ( minalign < inf.cc.defalign )
			si.N |= log2ceil(minalign)+1;
	}
	return true;
}




