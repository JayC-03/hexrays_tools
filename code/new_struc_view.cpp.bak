/* Custom viewer sample plugin.
 * Copyright (c) 2007 by Ilfak Guilfanov, ig@hexblog.com
 * Feel free to do whatever you want with this code.
 *
 * This sample plugin demonstates how to create and manipulate a simple
 * custom viewer in IDA Pro v5.1
 *
 * Custom viewers allow you to create a view which displays colored lines.
 * These colored lines are dynamically created by callback functions.
 *
 * Custom viewers are used in IDA Pro itself to display
 * the disassembly listng, structure, and enumeration windows.
 *
 * This sample plugin just displays several sample lines on the screen.
 * It displays a hint with the current line number.
 * The right-click menu contains one sample command.
 * It reacts to one hotkey.
 *
 * This plugin uses the simpleline_place_t class for the locations.
 * Custom viewers can use any decendant of the place_t class.
 * The place_t is responsible for supplying data to the viewer.
 */

//---------------------------------------------------------------------------
#ifdef __NT__
  #include <windows.h>
#else
  #define VK_ESCAPE 27
#endif
#include <hexrays.hpp>
#include <ida.hpp>
#include <idp.hpp>
#include <loader.hpp>
#include <kernwin.hpp>
#include <struct.hpp>
#include "new_struct.h"
#include "new_struc_place.h"
#include "helpers.h"

// Structure to keep all information about the our sample view
struct new_struc_info_t
{
  TForm *form;
  TCustomControl *cv;
  field_info_t * fi;
  new_struc_info_t(TForm *f) : form(f), cv(NULL) {}
};

//---------------------------------------------------------------------------
// get the word under the (keyboard or mouse) cursor
static bool get_current_word(TCustomControl *v, bool mouse, qstring &word)
{
  // query the cursor position
  int x, y;
  if ( get_custom_viewer_place(v, mouse, &x, &y) == NULL )
    return false;

  // query the line at the cursor
  char buf[MAXSTR];
  const char *line = get_custom_viewer_curline(v, mouse);
  tag_remove(line, buf, sizeof(buf));
  if ( x >= (int)strlen(buf) )
    return false;

  // find the beginning of the word
  char *ptr = buf + x;
  while ( ptr > buf && !isspace(ptr[-1]) )
    ptr--;

  // find the end of the word
  char *begin = ptr;
  ptr = buf + x;
  while ( !isspace(*ptr) && *ptr != '\0' )
    ptr++;

  word = qstring(begin, ptr-begin);
  return true;
}

//------------------------------------------------------------
// The user double clicked
static bool idaapi cb_dblclick(TCustomControl *cv, int shift, void *ud)
{
	new_struc_info_t *si = (new_struc_info_t *)ud;
	return false;
}


//---------------------------------------------------------------------------
// Sample callback function for the right-click menu
static bool idaapi remove_one(new_struc_info_t *nsi)
{
	new_struc_place_t * place; 
	place = (new_struc_place_t *)get_custom_viewer_place(nsi->cv, false, NULL, NULL);
	if(!place)
		return false;

	
	field_info_t::iterator iter =  nsi->fi->begin();
	advance(iter, place->idx);
	if (iter == nsi->fi->end())
		return false;

	scan_info_t & si = iter->second;
	int offset = iter->first;
	typevec_t::iterator iter1 = si.types.begin();
	std::advance(iter1, place->lnnum);	
	if (iter1 == si.types.end())
		return false;
	msg("removing\n");
	si.types.erase(iter1);
	refresh_custom_viewer(nsi->cv);
	return true;
}

static bool idaapi adjust_substruct(new_struc_info_t *nsi, bool add)
{
	new_struc_place_t * place; 
	place = (new_struc_place_t *)get_custom_viewer_place(nsi->cv, false, NULL, NULL);
	if(!place)
		return false;
	
	field_info_t::iterator iter =  nsi->fi->begin();
	advance(iter, place->idx);

	while(iter != nsi->fi->end())
	{
		if (add)
			++iter->second.substruct_counter;
		else
			--iter->second.substruct_counter;
		++iter;
	}	
	refresh_custom_viewer(nsi->cv);
	return true;
}


static bool idaapi set_current_offset(new_struc_info_t *nsi)
{
	new_struc_place_t * place; 
	place = (new_struc_place_t *)get_custom_viewer_place(nsi->cv, false, NULL, NULL);
	if(!place)
		return false;
	
	field_info_t::iterator iter =  nsi->fi->begin();
	advance(iter, place->idx);
	if (iter == nsi->fi->end())
		return false;

	nsi->fi->current_offset = iter->first;
	refresh_custom_viewer(nsi->cv);
	return true;
}

//---------------------------------------------------------------------------
// Keyboard callback
static bool idaapi ct_keyboard(TCustomControl * /*v*/, int key, int shift, void *ud)
{
  //if ( shift == 0 )
  {
    new_struc_info_t *si = (new_struc_info_t *)ud;
    switch ( key )
    {
      case 'N':
	
        return false;

	  case 'Y':
		  return false;
	  case VK_ADD:
	  case '+':
		  return adjust_substruct(si, true);
		  break;

	  case VK_MULTIPLY:
		  return set_current_offset(si);
		  break;

	  case VK_SUBTRACT:  
	  case '-':
		  return adjust_substruct(si, false);
		  break;

      case VK_ESCAPE:
        close_tform(si->form, FORM_SAVE);		
        return true;

	  case VK_DELETE:
		  {
			  return remove_one(si);			  
		  }
		  break;

	  case VK_RETURN:
		  break;
    }
  }
  return false;
}

//---------------------------------------------------------------------------
#define add_popup add_custom_viewer_popup_item

//---------------------------------------------------------------------------
static void idaapi ct_popup(TCustomControl *v, void *ud)
{
  // dynamically create custom popup items
  set_custom_viewer_popup_menu(v, NULL);

  // Create right-click menu on the fly
 
  //add_popup(v, "Scan for class functions", "S", scan_cb, ud);
  //add_popup(v, "add constructor / destructor", "", add_constructor_destuctor, ud);   
}

//---------------------------------------------------------------------------
// This callback will be called each time the keyboard cursor position
// is changed
static void idaapi ct_curpos(TCustomControl *v, void *)
{
  qstring word;
  /*
  if ( get_current_word(v, false, word) )
    msg("Current word is: %s\n", word.c_str());
	*/
}

//--------------------------------------------------------------------------
static int idaapi ui_callback(void *ud, int code, va_list va)
{
  new_struc_info_t *si = (new_struc_info_t *)ud;
  switch ( code )
  {
    // how to implement a simple hint callback
    case ui_get_custom_viewer_hint:
      {
        TCustomControl *viewer = va_arg(va, TCustomControl *);
        place_t *place         = va_arg(va, place_t *);
        int *important_lines   = va_arg(va, int *);
        qstring &hint          = *va_arg(va, qstring *);
        if ( si->cv == viewer ) // our viewer
        {
          if ( place == NULL )
            return 0;
		  new_struc_place_t *spl = (new_struc_place_t *)place;
          hint.sprnt("Hint for line %d", spl->idx);
          *important_lines = 1;
          return 1;
        }
        break;
      }
    case ui_tform_invisible:
      {
        TForm *f = va_arg(va, TForm *);
        if ( f == si->form )
        {
          delete si;
          unhook_from_notification_point(HT_UI, ui_callback, NULL);
        }
      }
      break;
  }
  return 0;
}

//---------------------------------------------------------------------------
// Create a custom view window
bool idaapi show_new_struc_view(field_info_t * fi)
{
  HWND hwnd = NULL;
  TForm *form = create_tform("new_struc", &hwnd);
  if ( hwnd == NULL )
  {    
    form = find_tform("new_struc");
    if ( form != NULL )
      switchto_tform(form, true);
    return true;
  }
  // allocate block to hold info about our sample view
  new_struc_info_t *si = new new_struc_info_t(form);

  // prepare the data to display. we could prepare it on the fly too.
  // but for that we have to use our own custom place_t class decendant.

  
  // create two place_t objects: for the minimal and maximal locations
  new_struc_place_t  s1;  
  new_struc_place_t s2(fi->size()-1);
  si->fi = fi;
  // create a custom viewer
  si->cv = create_custom_viewer("", (TWinControl *)form, &s1, &s2, &s1, 0, si->fi);
  // set the handlers so we can communicate with it
  set_custom_viewer_handlers(si->cv, ct_keyboard, ct_popup, cb_dblclick, ct_curpos, NULL, si);
  // also set the ui event callback
  hook_to_notification_point(HT_UI, ui_callback, si);
  // finally display the form on the screen
  open_tform(form, FORM_TAB|FORM_MENU|FORM_RESTORE);
  return true;
}